// Generated by CoffeeScript 1.12.5
(function() {
  var jenkinsBuild, jenkinsBuildById, jenkinsDescribe, jenkinsLast, jenkinsList, jobList, parseJobs, querystring, sendBuildTrigger;

  querystring = require('querystring');

  jobList = [];

  jenkinsBuildById = function(msg) {
    var job;
    job = jobList[parseInt(msg.match[1]) - 1];
    if (job) {
      msg.match[1] = job;
      return jenkinsBuild(msg);
    } else {
      return msg.reply("I couldn't find that job. Try `jenkins list` to get a list.");
    }
  };

  jenkinsBuild = function(msg, buildWithEmptyParameters) {
    var auth, command, escapedJobUrlParts, j, jobUrl, jobUrlPart, jobUrlParts, len, params, path, req, reqCrumb, url;
    url = process.env.HUBOT_JENKINS_URL;
    params = msg.match[3];
    command = buildWithEmptyParameters ? "buildWithParameters" : "build";
    jobUrl = "";
    jobUrlParts = msg.match[1].split(":");
    for (j = 0, len = jobUrlParts.length; j < len; j++) {
      jobUrlPart = jobUrlParts[j];
      escapedJobUrlParts = querystring.escape(jobUrlPart);
      jobUrl += "/job/" + escapedJobUrlParts;
    }
    path = params ? "" + url + jobUrl + "/buildWithParameters?" + params : "" + url + jobUrl + "/" + command;
    req = msg.http(path);
    if (process.env.HUBOT_JENKINS_AUTH) {
      auth = new Buffer(process.env.HUBOT_JENKINS_AUTH).toString('base64');
      req.headers({
        Authorization: "Basic " + auth
      });
      reqCrumb = msg.http(url + "/crumbIssuer/api/json");
      reqCrumb.headers({
        Authorization: "Basic " + auth
      });
      return reqCrumb.get()(function(err, res, body) {
        var content, ref;
        if (err) {
          return msg.reply("Jenkins says: " + err);
        } else if ((200 <= (ref = res.statusCode) && ref < 400)) {
          content = JSON.parse(body);
          console.log(body);
          console.log("Got Crumb " + content.crumbRequestField + " " + content.crumb);
          req.header(content.crumbRequestField, content.crumb);
          console.log("req:" + JSON.stringify(req));
          return sendBuildTrigger(msg, req, "" + url + jobUrl);
        } else if (400 === res.statusCode) {
          return msg.reply("400");
        } else if (404 === res.statusCode) {
          return msg.reply("404");
        } else {
          return msg.reply("Jenkins says: Status " + res.statusCode + " " + body);
        }
      });
    } else {
      return sendBuildTrigger(msg, req, "" + url + jobUrl);
    }
  };

  sendBuildTrigger = function(msg, req, jobLink) {
    req.header('Content-Length', 0);
    return req.post()(function(err, res, body) {
      var ref;
      if (err) {
        return msg.reply("Jenkins says: " + err);
      } else if ((200 <= (ref = res.statusCode) && ref < 400)) {
        return msg.reply("(" + res.statusCode + ") Build started for [" + msg.match[1] + "](" + jobLink + ")");
      } else if (400 === res.statusCode) {
        return jenkinsBuild(msg, true);
      } else if (404 === res.statusCode) {
        return msg.reply("Build not found, double check that it exists and is spelt correctly.");
      } else {
        return msg.reply("Jenkins says: Status " + res.statusCode + " " + body);
      }
    });
  };

  jenkinsDescribe = function(msg) {
    var auth, job, path, req, url;
    url = process.env.HUBOT_JENKINS_URL;
    job = msg.match[1];
    path = url + "/job/" + job + "/api/json";
    req = msg.http(path);
    if (process.env.HUBOT_JENKINS_AUTH) {
      auth = new Buffer(process.env.HUBOT_JENKINS_AUTH).toString('base64');
      req.headers({
        Authorization: "Basic " + auth
      });
    }
    req.header('Content-Length', 0);
    return req.get()(function(err, res, body) {
      var content, error, item, j, k, l, len, len1, len2, param, parameters, ref, ref1, ref2, report, response, tmpDefault, tmpDescription, tmpReport;
      if (err) {
        return msg.send("Jenkins says: " + err);
      } else {
        response = "";
        try {
          content = JSON.parse(body);
          response += "JOB: " + content.displayName + "\n";
          response += "URL: " + content.url + "\n";
          if (content.description) {
            response += "DESCRIPTION: " + content.description + "\n";
          }
          response += "ENABLED: " + content.buildable + "\n";
          response += "STATUS: " + content.color + "\n";
          tmpReport = "";
          if (content.healthReport.length > 0) {
            ref = content.healthReport;
            for (j = 0, len = ref.length; j < len; j++) {
              report = ref[j];
              tmpReport += "\n  " + report.description;
            }
          } else {
            tmpReport = " unknown";
          }
          response += "HEALTH: " + tmpReport + "\n";
          parameters = "";
          ref1 = content.actions;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            item = ref1[k];
            if (item.parameterDefinitions) {
              ref2 = item.parameterDefinitions;
              for (l = 0, len2 = ref2.length; l < len2; l++) {
                param = ref2[l];
                tmpDescription = param.description ? " - " + param.description + " " : "";
                tmpDefault = param.defaultParameterValue ? " (default=" + param.defaultParameterValue.value + ")" : "";
                parameters += "\n  " + param.name + tmpDescription + tmpDefault;
              }
            }
          }
          if (parameters !== "") {
            response += "PARAMETERS: " + parameters + "\n";
          }
          msg.send(response);
          if (!content.lastBuild) {
            return;
          }
          path = url + "/job/" + job + "/" + content.lastBuild.number + "/api/json";
          req = msg.http(path);
          if (process.env.HUBOT_JENKINS_AUTH) {
            auth = new Buffer(process.env.HUBOT_JENKINS_AUTH).toString('base64');
            req.headers({
              Authorization: "Basic " + auth
            });
          }
          req.header('Content-Length', 0);
          return req.get()(function(err, res, body) {
            var error, jobdate, jobstatus;
            if (err) {
              return msg.send("Jenkins says: " + err);
            } else {
              response = "";
              try {
                content = JSON.parse(body);
                jobstatus = content.result || 'PENDING';
                jobdate = new Date(content.timestamp);
                response += "LAST JOB: " + jobstatus + ", " + jobdate + "\n";
                return msg.send(response);
              } catch (error1) {
                error = error1;
                return msg.send(error);
              }
            }
          });
        } catch (error1) {
          error = error1;
          return msg.send(error);
        }
      }
    });
  };

  jenkinsLast = function(msg) {
    var auth, job, path, req, url;
    url = process.env.HUBOT_JENKINS_URL;
    job = msg.match[1];
    path = url + "/job/" + job + "/lastBuild/api/json";
    req = msg.http(path);
    if (process.env.HUBOT_JENKINS_AUTH) {
      auth = new Buffer(process.env.HUBOT_JENKINS_AUTH).toString('base64');
      req.headers({
        Authorization: "Basic " + auth
      });
    }
    req.header('Content-Length', 0);
    return req.get()(function(err, res, body) {
      var content, response;
      if (err) {
        return msg.send("Jenkins says: " + err);
      } else {
        response = "";
        try {
          content = JSON.parse(body);
          response += "NAME: " + content.fullDisplayName + "\n";
          response += "URL: " + content.url + "\n";
          if (content.description) {
            response += "DESCRIPTION: " + content.description + "\n";
          }
          response += "BUILDING: " + content.building + "\n";
          return msg.send(response);
        } catch (error1) {}
      }
    });
  };

  jenkinsList = function(msg) {
    var auth, depth, filter, i, j, k, ref, ref1, req, suffix, url;
    url = process.env.HUBOT_JENKINS_URL;
    filter = new RegExp(msg.match[2], 'i');
    if (process.env.HUBOT_JENKINS_JOB_DEPTH) {
      depth = parseInt(process.env.HUBOT_JENKINS_JOB_DEPTH, 10);
    } else {
      depth = 1;
    }
    suffix = "?tree=";
    for (i = j = 1, ref = depth + 1; j < ref; i = j += 1) {
      if (i < depth) {
        suffix += "jobs[name,buildable,color,";
      } else {
        suffix += "jobs[name,buildable,color";
      }
    }
    for (i = k = 1, ref1 = depth + 1; k < ref1; i = k += 1) {
      suffix += "]";
    }
    req = msg.http((url + "/api/json") + suffix);
    if (process.env.HUBOT_JENKINS_AUTH) {
      auth = new Buffer(process.env.HUBOT_JENKINS_AUTH).toString('base64');
      req.headers({
        Authorization: "Basic " + auth
      });
    }
    return req.get()(function(err, res, body) {
      var content;
      if (err) {
        return msg.send("Jenkins says: " + err);
      } else {
        content = JSON.parse(body);
        res = parseJobs(0, "", content.jobs, filter);
        return msg.send(res);
      }
    });
  };

  parseJobs = function(depth, prefix, jobs, filter) {
    var i, index, j, job, k, len, ref, res, state;
    res = "";
    for (j = 0, len = jobs.length; j < len; j++) {
      job = jobs[j];
      if (depth > 0 || filter.test(job.name)) {
        for (i = k = 1, ref = depth + 1; k < ref; i = k += 1) {
          res += "\t";
        }
        if (job._class === "com.cloudbees.hudson.plugins.folder.Folder") {
          res += "Folder " + prefix + job.name + ":\n";
        } else {
          if (job._class === "org.jenkinsci.plugins.workflow.multibranch.WorkflowMultiBranchProject") {
            res += "MultiBranchProject " + prefix + job.name + ":\n";
          } else {
            index = jobList.indexOf(prefix + job.name);
            if (index === -1) {
              jobList.push(prefix + job.name);
              index = jobList.indexOf(prefix + job.name);
            }
            state = job.color === "red" ? "FAIL" : "PASS";
            res += "[" + (index + 1) + "] " + state + " " + prefix + job.name + "\n";
          }
        }
      }
      if (job.jobs) {
        res += parseJobs(depth + 1, prefix + job.name + ":", job.jobs, filter);
      }
    }
    return res;
  };

  module.exports = function(robot) {
    robot.respond(/j(?:enkins)? build ([\:\w\.\-_ ]+)(, (.+))?/i, function(msg) {
      return jenkinsBuild(msg, false);
    });
    robot.respond(/j(?:enkins)? b (\d+)/i, function(msg) {
      return jenkinsBuildById(msg);
    });
    robot.respond(/j(?:enkins)? list( (.+))?/i, function(msg) {
      return jenkinsList(msg);
    });
    robot.respond(/j(?:enkins)? describe (.*)/i, function(msg) {
      return jenkinsDescribe(msg);
    });
    robot.respond(/j(?:enkins)? last (.*)/i, function(msg) {
      return jenkinsLast(msg);
    });
    return robot.jenkins = {
      list: jenkinsList,
      build: jenkinsBuild,
      describe: jenkinsDescribe,
      last: jenkinsLast
    };
  };

}).call(this);

//# sourceMappingURL=jenkins.js.map
